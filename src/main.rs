#[macro_use] extern crate rocket;
#[macro_use] extern crate rocket_sync_db_pools;
#[macro_use] extern crate diesel;

use rocket::serde::{Deserialize, Serialize};
use rocket::serde::json::Json; 
use self::diesel::prelude::*;
use rocket::fs::{FileServer, relative};
use rocket::response::{Debug};

// Import the autogenerated diesel schema
mod schema;
use crate::schema::*;

// The connection between the rocket and diesel
// Uses a thread pool to prevent blocking execution
// as diesel async isn't quite ready yet...
#[database("translations")]
struct TranslationsDb(diesel::MysqlConnection);

#[derive(Serialize, Deserialize, Queryable, Insertable)]
#[table_name="phrase"]
struct Phrase {
    id: Option<i64>,
    english_text: String,
    translation_text: String,
}

// Produce a POST body contents structure that we can recieve to specify a single completion
#[derive(Deserialize)]
struct CompletionID {
    translation_id: i64,
}

#[derive(Serialize)]
struct ReturnData {
    status: &'static str,
    message: Option<String>,
    data: Option<Vec<Phrase>>
}

#[post("/add_completion.json", data = "<post_data>")]
async fn add_completion(db: TranslationsDb, post_data: Json<Phrase>) -> Result<Json<ReturnData>, Json<ReturnData>> {
    let response = db.run(move |conn| {
        diesel::insert_into(phrase::table)
            .values(&*post_data)
            .execute(conn)
    }).await;

    // API error handling
    match response {
        Ok(_n_rows_changed) => Ok(Json(ReturnData {
            status: "Success!",
            message: Some(format!("Added completion.")),
            data: None
        })),
        Err(error) => Ok(Json(ReturnData {
            status: "Failure",
            message: Some(format!("Error: {}", error)),
            data: None,
        }))
    }
}

#[get("/get_completions.json?<search_phrase>")]
async fn get_completions(db: TranslationsDb, search_phrase: String) -> Result<Json<ReturnData>, Json<ReturnData>> {
    let search_phrase_out = search_phrase.clone();
    let response = db.run(move |conn| {
        phrase::table.filter(phrase::english_text
            .like(format!("%{}%", search_phrase)))
            .load(conn)
    }).await; 

    // API error handling
    match response {
        Ok(data) => Ok(Json(ReturnData {
            status: "Success!",
            message: Some(format!("Found completions for \"{}\"", search_phrase_out)),
            data: Some(data), 
        })),
        Err(error) => Ok(Json(ReturnData {
            status: "Failure",
            message: Some(format!("Error: {}", error)),
            data: None,
        }))
    }
}

#[post("/remove_completion.json?", data = "<post_data>")]
async fn remove_completions(db: TranslationsDb, post_data: Json<CompletionID>) -> Result<Json<ReturnData>, Json<ReturnData>>{
    let id: i64 = post_data.translation_id.clone();
    let response = db.run(move |conn| {
        diesel::delete(phrase::table)
            .filter(phrase::id.eq(id))
            .execute(conn)
    }).await; 

    // API error handling
    match response {
        Ok(_response) => Ok(Json(ReturnData {
            status: "Success!",
            message: Some(format!("Removed completion with id {}", id)),
            data: None, 
        })),
        Err(error) => Ok(Json(ReturnData {
            status: "Failure",
            message: Some(format!("Error: {}", error)),
            data: None,
        }))
    }
}

// Launch the web-server, composed of
// Static assets @ "/" -> E.g. the page, html, css, js and images
// The database connection pool (expressed as a Rocket fairing)
// The API routes @ "/api/"
#[launch]
async fn rocket() -> _ {
    rocket::build()
        .mount("/", FileServer::from(relative!("static")))
        .attach(TranslationsDb::fairing())
        .mount("/api/1.0/", routes![add_completion, get_completions, remove_completions])
}