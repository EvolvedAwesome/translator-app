#[macro_use] extern crate rocket;
#[macro_use] extern crate rocket_sync_db_pools;
#[macro_use] extern crate diesel;

use rocket::serde::{Deserialize, Serialize};
use rocket::serde::json::Json; 
use self::diesel::prelude::*;
use rocket::fs::{FileServer, relative};
use rocket::response::{Debug};

// Import the autogenerated diesel schema
mod schema;
use crate::schema::*;

// The connection between the rocket and diesel
// Uses a thread pool to prevent blocking execution
// as diesel async isn't quite ready yet...
#[database("translations")]
struct TranslationsDb(diesel::MysqlConnection);

// An alias of the result method that means we only have to define a success condition
type Result<T, E = Debug<diesel::result::Error>> = std::result::Result<T, E>;

#[derive(Serialize, Deserialize, Queryable, Insertable)]
#[table_name="phrase"]
struct Phrase {
    id: Option<i64>,
    english_text: String,
    translation_text: String,
}

#[post("/add_completion.json", data = "<post_data>")]
async fn add_completion(db: TranslationsDb, post_data: Json<Phrase>) -> Result<Json<&'static str>> {
    db.run(move |conn| {
        diesel::insert_into(phrase::table)
            .values(&*post_data)
            .execute(conn)
    }).await?;
    Ok(Json("Success!"))
}

#[get("/get_completions.json?<search_phrase>")]
async fn get_completions(db: TranslationsDb, search_phrase: String) -> Result<Json<Vec<Phrase>>> {
    let data: Vec<Phrase> = db.run(move |conn| {
        phrase::table.filter(phrase::english_text.like(format!("%{}%", search_phrase))).load(conn)
    }).await?; 

    Ok(Json(data))
}

#[launch]
async fn rocket() -> _ {
    rocket::build()
        .mount("/", FileServer::from(relative!("static")))
        .attach(TranslationsDb::fairing())
        .mount("/api", routes![add_completion, get_completions])
}